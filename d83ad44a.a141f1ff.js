(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{156:function(e,o,a){"use strict";a.r(o),a.d(o,"frontMatter",(function(){return s})),a.d(o,"metadata",(function(){return d})),a.d(o,"toc",(function(){return c})),a.d(o,"default",(function(){return u}));var n=a(3),t=a(7),r=(a(0),a(181)),i=["components"],s={id:"i2c",title:"I2C",sidebar_label:"I2C"},d={unversionedId:"glossario/protocolos/i2c",id:"glossario/protocolos/i2c",isDocsHomePage:!1,title:"I2C",description:"Escrito por Matheus Parracho",source:"@site/docs/glossario/protocolos/i2c.md",slug:"/glossario/protocolos/i2c",permalink:"/documentation/docs/glossario/protocolos/i2c",editUrl:"https://github.com/minervarockets/documentation/edit/master/my-website/docs/glossario/protocolos/i2c.md",version:"current",sidebar_label:"I2C",sidebar:"Docs",previous:{title:"Carga e Descarga das Baterias",permalink:"/documentation/docs/glossario/testes/cargaedescarga"},next:{title:"SPI",permalink:"/documentation/docs/glossario/protocolos/spi"}},c=[{value:"O que \xe9?",id:"o-que-\xe9",children:[]},{value:"Hardware",id:"hardware",children:[]},{value:"Como funciona a comunica\xe7\xe3o?",id:"como-funciona-a-comunica\xe7\xe3o",children:[]},{value:"No Arduino",id:"no-arduino",children:[]}],l={toc:c};function u(e){var o=e.components,s=Object(t.a)(e,i);return Object(r.b)("wrapper",Object(n.a)({},l,s,{components:o,mdxType:"MDXLayout"}),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Escrito por Matheus Parracho")),Object(r.b)("h2",{id:"o-que-\xe9"},"O que \xe9?"),Object(r.b)("p",null,"O barramento de circuito integrado (I2C) \xe9 uma interface serial de dois fios desenvolvida originalmente pela Phillips Corporation no in\xedcio da d\xe9cada de 90. Ele \xe9 utilizado para a comunica\xe7\xe3o entre dispositivos de maneira bem eficiente e r\xe1pida."),Object(r.b)("h2",{id:"hardware"},"Hardware"),Object(r.b)("p",null,"O barramento I2C \xe9 composto de dois fios, chamados de SDA (Serial Data) e SCL (Serial Clock) , al\xe9m de sua alimenta\xe7\xe3o (VCC), tipicamente de 3.3V ou 5V."),Object(r.b)("p",null,"Este protocolo especifica dois sinais de comunica\xe7\xe3o, um com o sinal de clock - SCL (gerado pelo mestre), e outro de dados - SDA, bidirecional."),Object(r.b)("p",null,"Os dispositivos s\xe3o reconhecidos atrav\xe9s de endere\xe7os, que podem ser de 7 bits, 10 bits e at\xe9 16 bits. Assim j\xe1 \xe9 poss\xedvel identificar uma limita\xe7\xe3o no n\xfamero de dispositivos."),Object(r.b)("p",null,"Al\xe9m disso, outro fator complicante se torna que a montagem n\xe3o pode ultrapassar poucos metros de fios, pois a capacit\xe2ncia total m\xe1xima, em torno de 400pf, impede o funcionamento correto do barramento nessas dist\xe2ncias."),Object(r.b)("p",null,Object(r.b)("img",{alt:"img",src:a(357).default})),Object(r.b)("h2",{id:"como-funciona-a-comunica\xe7\xe3o"},"Como funciona a comunica\xe7\xe3o?"),Object(r.b)("p",null,"No estado neutro do barramento I2C,  o valor high \xe9 mantido em ambas as linhas de comunica\xe7\xe3o. Para se iniciar a comunica\xe7\xe3o, SDA \xe9 trazido para o valor low pelo mestre. Para escrever dados no barramento, SCL pulsa, e a cada pulso, o valor em SDA \xe9 lido como um bit, come\xe7ando do LSB (Least Significant Bit - Bit menos significativo)."),Object(r.b)("p",null,"Logo ap\xf3s SDA ser trazida pra baixo, o mestre escreve o endere\xe7o do dispositivo que ele deseja se comunicar, por exemplo 0xC0, caso o dispositivo exista, ele responder\xe1 como um ACK (Acknowledgement - Reconhecimento), um pulso na linha SCL. Ent\xe3o come\xe7a a transfer\xeancia de dados, o mestre escreve o endere\xe7o do registrador no escravo que ele deseja ler ou escrever (R/W) e opera ent\xe3o, em sequencia, podendo ler/escrever um ou mais registrador."),Object(r.b)("p",null,Object(r.b)("img",{alt:"img",src:a(358).default})),Object(r.b)("h2",{id:"no-arduino"},"No Arduino"),Object(r.b)("p",null,"Para a comunica\xe7\xe3o com o arduino, basta ligarmos a porta A5 no SCL e o A4 no SDA, como mostrado na figura abaixo:"),Object(r.b)("p",null,Object(r.b)("img",{alt:"img",src:a(359).default})),Object(r.b)("p",null,"A documenta\xe7\xe3o da biblioteca respons\xe1vel para a comunica\xe7\xe3o I2C pode ser encontrada na descri\xe7\xe3o do ",Object(r.b)("a",{parentName:"p",href:"https://www.arduino.cc/en/reference/wire"},"Wire.h"),"."),Object(r.b)("p",null,"E abaixo temos um exemplo mostrando a comunica\xe7\xe3o entre Arduinos utilizando o protocolo I2C.\n\xc9 respons\xe1vel por alterar o estado do LED conectado a placa Slave quando o botao ligado a placa Master for pressionado."),Object(r.b)("p",null,"C\xf3digo do MASTER:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cpp"},'#include "Wire.h"\n\n#define buttonPin 4 // numero do pino onde o botao esta conectado\n  \n  \n// endereco do modulo slave que pode ser um valor de 0 a 255\n#define slaveAdress 0x08\n\nboolean buttonState;             // estado atual do botao\nboolean lastButtonState = LOW;   // valor da ultima leitura do botao\nboolean ledState = HIGH;         // estado atual do LED\n\n// as variaveis a seguir sao do tipo long por conta que o tempo, medido \n// em milessegundos alcancara rapidamente um numero grande demais para \n// armazenar em uma variavel do tipo int\nunsigned long lastDebounceTime = 0;  // tempo da ultima modificacao do estado do LED\n\n// tempo de debounce; aumentar se o LED oscilar; espera-se que o LED acenda\n// apenas se o botao for pressionado por mais de 50ms\nunsigned long debounceDelay = 50;    \n\nvoid setup() {\n  Wire.begin(); // ingressa ao barramento I2C\n  \n  // configura o pino do botao como entrada com resistor de pullup interno\n  pinMode(buttonPin, INPUT_PULLUP);\n}\n\nvoid loop() {\n  // le o estado do botao e salva em uma variavel local\n  int reading = digitalRead(buttonPin);\n\n  // verifica se voce apenas apertou o botao (i.e. se a entrada foi de LOW \n  // to HIGH), e se ja esperou tempo suficiente para ignorar qualquer ruido\n\n  // se a entrada foi alterada devido ao ruido ou botao ter sido pressionado:\n  if (reading != lastButtonState) {\n    // reseta o tempo do debounce\n    lastDebounceTime = millis();\n  }\n  \n  if ((millis() - lastDebounceTime) > debounceDelay) {\n    // qualquer que seja a leitura atual, ela se manteve por um tempo maior\n    // que o nosso debounce delay, ent\xe3o atualizemos o estado atual:\n\n    // se o estado do botao foi alterado:\n    if (reading != buttonState) {\n      buttonState = reading;\n\n      // apenas altera o estado do LED se o novo estado do botao e HIGH\n      if (buttonState == HIGH) {\n        ledState = !ledState;\n        // incia a transmissao para o endereco 0x08 (slaveAdress)\n        Wire.beginTransmission(slaveAdress);\n        Wire.write(ledState); // envia um byte contendo o estado do LED\n        Wire.endTransmission(); // encerra a transmissao\n      }\n    }\n  }\n  // salva a leitura. No proximo laco este sera o ultimo \n  // estado do botao (lastButtonState)\n  lastButtonState = reading;\n}\n')),Object(r.b)("p",null,"C\xf3digo do SLAVE:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cpp"},'#include "Wire.h"\n\n#define ledPin 7 // numero do pino onde o LED esta conectado\n  \n  \n// endereco do modulo slave que pode ser um valor de 0 a 255\n#define myAdress 0x08\n\nvoid setup() {\n  // ingressa ao barramento I2C com o endere\xe7o definido no myAdress (0x08)\n  Wire.begin(myAdress);\n\n  //Registra um evento para ser chamado quando chegar algum dado via I2C\n  Wire.onReceive(receiveEvent);\n\n  pinMode(ledPin, OUTPUT);  // configura o pino do LED como saida\n}\n\nvoid loop() {\n  // nada para ser exexutado\n}\n\n// funcao executada sempre que algum dado e recebido no barramento I2C\n// vide "void setup()"\nvoid receiveEvent(int howMany) {\n  // verifica se existem dados para serem lidos no barramento I2C\n  if (Wire.available()) {\n    // le o byte recebido\n    char received = Wire.read();\n\n    // se o byte recebido for igual a 0, apaga o LED\n    if (received == 0) {\n      digitalWrite(ledPin, LOW);\n    }\n\n    // se o byte recebido for igual a 1 acende o LED\n    if (received == 1) {\n      digitalWrite(ledPin, HIGH);\n    }\n  }\n}\n')))}u.isMDXComponent=!0},181:function(e,o,a){"use strict";a.d(o,"a",(function(){return u})),a.d(o,"b",(function(){return b}));var n=a(0),t=a.n(n);function r(e,o,a){return o in e?Object.defineProperty(e,o,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[o]=a,e}function i(e,o){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);o&&(n=n.filter((function(o){return Object.getOwnPropertyDescriptor(e,o).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var o=1;o<arguments.length;o++){var a=null!=arguments[o]?arguments[o]:{};o%2?i(Object(a),!0).forEach((function(o){r(e,o,a[o])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(o){Object.defineProperty(e,o,Object.getOwnPropertyDescriptor(a,o))}))}return e}function d(e,o){if(null==e)return{};var a,n,t=function(e,o){if(null==e)return{};var a,n,t={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],o.indexOf(a)>=0||(t[a]=e[a]);return t}(e,o);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],o.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(t[a]=e[a])}return t}var c=t.a.createContext({}),l=function(e){var o=t.a.useContext(c),a=o;return e&&(a="function"==typeof e?e(o):s(s({},o),e)),a},u=function(e){var o=l(e.components);return t.a.createElement(c.Provider,{value:o},e.children)},m={inlineCode:"code",wrapper:function(e){var o=e.children;return t.a.createElement(t.a.Fragment,{},o)}},p=t.a.forwardRef((function(e,o){var a=e.components,n=e.mdxType,r=e.originalType,i=e.parentName,c=d(e,["components","mdxType","originalType","parentName"]),u=l(a),p=n,b=u["".concat(i,".").concat(p)]||u[p]||m[p]||r;return a?t.a.createElement(b,s(s({ref:o},c),{},{components:a})):t.a.createElement(b,s({ref:o},c))}));function b(e,o){var a=arguments,n=o&&o.mdxType;if("string"==typeof e||n){var r=a.length,i=new Array(r);i[0]=p;var s={};for(var d in o)hasOwnProperty.call(o,d)&&(s[d]=o[d]);s.originalType=e,s.mdxType="string"==typeof e?e:n,i[1]=s;for(var c=2;c<r;c++)i[c]=a[c];return t.a.createElement.apply(null,i)}return t.a.createElement.apply(null,a)}p.displayName="MDXCreateElement"},357:function(e,o,a){"use strict";a.r(o),o.default=a.p+"assets/images/estrutura-157de52ddba692c93c75394685e045dc.png"},358:function(e,o,a){"use strict";a.r(o),o.default=a.p+"assets/images/comunicacao-194fb32ebba31f377d0ac0a759ab6291.png"},359:function(e,o,a){"use strict";a.r(o),o.default=a.p+"assets/images/arduino_i2c-1e777505e02e76d08ff58f9f05907645.jpg"}}]);