(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{166:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return c})),t.d(n,"metadata",(function(){return s})),t.d(n,"toc",(function(){return l})),t.d(n,"default",(function(){return d}));var i=t(3),a=t(7),r=(t(0),t(179)),o=["components"],c={id:"leituraescrita",title:"Leitura e Escrita no SD",sidebar_label:"Leitura e Escrita no SD"},s={unversionedId:"glossario/testes/leituraescrita",id:"glossario/testes/leituraescrita",isDocsHomePage:!1,title:"Leitura e Escrita no SD",description:"Escrito por Gabriel Aleksandravicius",source:"@site/docs/glossario/testes/leituraescrita.md",slug:"/glossario/testes/leituraescrita",permalink:"/documentation/docs/glossario/testes/leituraescrita",editUrl:"https://github.com/minervarockets/documentation/edit/master/my-website/docs/glossario/testes/leituraescrita.md",version:"current",sidebar_label:"Leitura e Escrita no SD",sidebar:"Docs",previous:{title:"Telemetria",permalink:"/documentation/docs/glossario/testes/telemetria"},next:{title:"Carga e Descarga das Baterias",permalink:"/documentation/docs/glossario/testes/cargaedescarga"}},l=[{value:"Objetivo",id:"objetivo",children:[]},{value:"Como fazer",id:"como-fazer",children:[{value:"Hardware",id:"hardware",children:[]},{value:"Biblioteca",id:"biblioteca",children:[]},{value:"C\xf3digo de exemplo",id:"c\xf3digo-de-exemplo",children:[]},{value:"Exemplo de output",id:"exemplo-de-output",children:[]}]}],u={toc:l};function d(e){var n=e.components,t=Object(a.a)(e,o);return Object(r.b)("wrapper",Object(i.a)({},u,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Escrito por Gabriel Aleksandravicius")),Object(r.b)("h2",{id:"objetivo"},"Objetivo"),Object(r.b)("p",null,"O objetivo do teste de leitura e escrita do cart\xe3o SD \xe9 verificar a velocidade m\xe1xima com que conseguimos acessar, ler e salvar dados no cart\xe3o SD com o m\xf3dulo utilizado. "),Object(r.b)("h2",{id:"como-fazer"},"Como fazer"),Object(r.b)("h3",{id:"hardware"},"Hardware"),Object(r.b)("p",null,"Os m\xf3dulos SD se comunicam com o microcontrolador atrav\xe9s do protocolo SPI, portanto ser\xe3o necess\xe1rios pelo menos os seguintes pinos: VCC e GND, MOSI, MISO, CLK e CS. O m\xf3dulo da Adafruit utilizado no Aurora v2 possui tamb\xe9m o pino CD."),Object(r.b)("h3",{id:"biblioteca"},"Biblioteca"),Object(r.b)("p",null,"Existem duas bibliotecas principais de SD: Sd, padr\xe3o do Arduino, e SdFat, desenvolvida pelo Bill Greiman. A primeira \xe9 bem funcional na maioria dos casos, por\xe9m falha em situa\xe7\xf5es mais extremas onde maiores velocidades s\xe3o exigidas. A segunda j\xe1 \xe9 mais otimizada para isso, portanto optamos por ela. Voc\xea pode encontr\xe1-la na aba de ",Object(r.b)("em",{parentName:"p"},"Libraries")," do PlatformIO ou no seu",Object(r.b)("a",{parentName:"p",href:"https://github.com/greiman/SdFat"},"reposit\xf3rio do github"),"."),Object(r.b)("p",null,"Uma boa not\xedcia \xe9 que essa biblioteca j\xe1 disponibiliza uma s\xe9rie de c\xf3digos de exemplos \xfateis, um deles sendo justamente um teste de benchmark onde s\xe3o avaliadas as lat\xeancias m\xe1xima, m\xednima e m\xe9dia da leitura e escrita no cart\xe3o."),Object(r.b)("h3",{id:"c\xf3digo-de-exemplo"},"C\xf3digo de exemplo"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cpp"},'// O objetivo deste c\xf3digo \xe9 testar os tempos de leitura e escrita\n// do seu m\xf3dulo do cart\xe3o SD.\n// Verifique os pinos e a frequ\xeancia de clock.\n\n#include <SPI.h>\n#include "SdFat.h"\n#include "sdios.h"\n#include "FreeStack.h"\n\n// SD_FAT_TYPE = 0 for SdFat/File as defined in SdFatConfig.h,\n// 1 for FAT16/FAT32, 2 for exFAT, 3 for FAT16/FAT32 and exFAT.\n#define SD_FAT_TYPE 0\n/*\n  Change the value of SD_CS_PIN if you are using SPI and\n  your hardware does not use the default value, SS.\n  Common values are:\n  Arduino Ethernet shield: pin 4\n  Sparkfun SD shield: pin 8\n  Adafruit SD shields and modules: pin 10\n*/\n// SDCARD_SS_PIN is defined for the built-in SD on some boards.\n#ifndef SDCARD_SS_PIN\nconst uint8_t SD_CS_PIN = SS;\n#else  // SDCARD_SS_PIN\n// Assume built-in SD is used.\nconst uint8_t SD_CS_PIN = SDCARD_SS_PIN;\n#endif  // SDCARD_SS_PIN\n\n// Try max SPI clock for an SD. Reduce SPI_CLOCK if errors occur.\n#define SPI_CLOCK SD_SCK_MHZ(50)\n\n// Try to select the best SD card configuration.\n#if HAS_SDIO_CLASS\n#define SD_CONFIG SdioConfig(FIFO_SDIO)\n#elif ENABLE_DEDICATED_SPI\n#define SD_CONFIG SdSpiConfig(SD_CS_PIN, DEDICATED_SPI, SPI_CLOCK)\n#else  // HAS_SDIO_CLASS\n#define SD_CONFIG SdSpiConfig(SD_CS_PIN, SHARED_SPI, SPI_CLOCK)\n#endif  // HAS_SDIO_CLASS\n\n// Set PRE_ALLOCATE true to pre-allocate file clusters.\nconst bool PRE_ALLOCATE = true;\n\n// Set SKIP_FIRST_LATENCY true if the first read/write to the SD can\n// be avoid by writing a file header or reading the first record.\nconst bool SKIP_FIRST_LATENCY = true;\n\n// Size of read/write.\nconst size_t BUF_SIZE = 512;\n\n// File size in MB where MB = 1,000,000 bytes.\nconst uint32_t FILE_SIZE_MB = 5;\n\n// Write pass count.\nconst uint8_t WRITE_COUNT = 2;\n\n// Read pass count.\nconst uint8_t READ_COUNT = 2;\n//==============================================================================\n// End of configuration constants.\n//------------------------------------------------------------------------------\n// File size in bytes.\nconst uint32_t FILE_SIZE = 1000000UL*FILE_SIZE_MB;\n\n// Insure 4-byte alignment.\nuint32_t buf32[(BUF_SIZE + 3)/4];\nuint8_t* buf = (uint8_t*)buf32;\n\n#if SD_FAT_TYPE == 0\nSdFat sd;\nFile file;\n#elif SD_FAT_TYPE == 1\nSdFat32 sd;\nFile32 file;\n#elif SD_FAT_TYPE == 2\nSdExFat sd;\nExFile file;\n#elif SD_FAT_TYPE == 3\nSdFs sd;\nFsFile file;\n#else  // SD_FAT_TYPE\n#error Invalid SD_FAT_TYPE\n#endif  // SD_FAT_TYPE\n\n// Serial output stream\nArduinoOutStream cout(Serial);\n//------------------------------------------------------------------------------\n// Store error strings in flash to save RAM.\n#define error(s) sd.errorHalt(&Serial, F(s))\n//------------------------------------------------------------------------------\nvoid cidDmp() {\n  cid_t cid;\n  if (!sd.card()->readCID(&cid)) {\n\n    error("readCID failed");\n  }\n  cout << F("\\nManufacturer ID: ");\n  cout << hex << int(cid.mid) << dec << endl;\n  cout << F("OEM ID: ") << cid.oid[0] << cid.oid[1] << endl;\n  cout << F("Product: ");\n  for (uint8_t i = 0; i < 5; i++) {\n    cout << cid.pnm[i];\n  }\n  cout << F("\\nVersion: ");\n  cout << int(cid.prv_n) << \'.\' << int(cid.prv_m) << endl;\n  cout << F("Serial number: ") << hex << cid.psn << dec << endl;\n  cout << F("Manufacturing date: ");\n  cout << int(cid.mdt_month) << \'/\';\n  cout << (2000 + cid.mdt_year_low + 10 * cid.mdt_year_high) << endl;\n  cout << endl;\n}\n//------------------------------------------------------------------------------\nvoid clearSerialInput() {\n  uint32_t m = micros();\n  do {\n    if (Serial.read() >= 0) {\n      m = micros();\n    }\n  } while (micros() - m < 10000);\n}\n//------------------------------------------------------------------------------\nvoid setup() {\n  Serial.begin(9600);\n\n  // Wait for USB Serial\n  while (!Serial) {\n    SysCall::yield();\n  }\n  delay(1000);\n  cout << F("\\nUse a freshly formatted SD for best performance.\\n");\n  if (!ENABLE_DEDICATED_SPI) {\n    cout << F(\n      "\\nSet ENABLE_DEDICATED_SPI nonzero in\\n"\n      "SdFatConfig.h for best SPI performance.\\n");\n  }\n  // use uppercase in hex and use 0X base prefix\n  cout << uppercase << showbase << endl;\n}\n//------------------------------------------------------------------------------\nvoid loop() {\n  float s;\n  uint32_t t;\n  uint32_t maxLatency;\n  uint32_t minLatency;\n  uint32_t totalLatency;\n  bool skipLatency;\n\n  // Discard any input.\n  clearSerialInput();\n\n  // F() stores strings in flash to save RAM\n  cout << F("Type any character to start\\n");\n  while (!Serial.available()) {\n    SysCall::yield();\n  }\n#if HAS_UNUSED_STACK\n  cout << F("FreeStack: ") << FreeStack() << endl;\n#endif  // HAS_UNUSED_STACK\n\n  if (!sd.begin(SD_CONFIG)) {\n    sd.initErrorHalt(&Serial);\n  }\n  if (sd.fatType() == FAT_TYPE_EXFAT) {\n    cout << F("Type is exFAT") << endl;\n  } else {\n    cout << F("Type is FAT") << int(sd.fatType()) << endl;\n  }\n\n  cout << F("Card size: ") << sd.card()->sectorCount()*512E-9;\n  cout << F(" GB (GB = 1E9 bytes)") << endl;\n\n  cidDmp();\n\n  // open or create file - truncate existing file.\n  if (!file.open("bench.dat", O_RDWR | O_CREAT | O_TRUNC)) {\n    error("open failed");\n  }\n\n  // fill buf with known data\n  if (BUF_SIZE > 1) {\n    for (size_t i = 0; i < (BUF_SIZE - 2); i++) {\n      buf[i] = \'A\' + (i % 26);\n    }\n    buf[BUF_SIZE-2] = \'\\r\';\n  }\n  buf[BUF_SIZE-1] = \'\\n\';\n\n  cout << F("FILE_SIZE_MB = ") << FILE_SIZE_MB << endl;\n  cout << F("BUF_SIZE = ") << BUF_SIZE << F(" bytes\\n");\n  cout << F("Starting write test, please wait.") << endl << endl;\n\n  // do write test\n  uint32_t n = FILE_SIZE/BUF_SIZE;\n  cout <<F("write speed and latency") << endl;\n  cout << F("speed,max,min,avg") << endl;\n  cout << F("KB/Sec,usec,usec,usec") << endl;\n  for (uint8_t nTest = 0; nTest < WRITE_COUNT; nTest++) {\n    file.truncate(0);\n    if (PRE_ALLOCATE) {\n      if (!file.preAllocate(FILE_SIZE)) {\n        error("preAllocate failed");\n      }\n    }\n    maxLatency = 0;\n    minLatency = 9999999;\n    totalLatency = 0;\n    skipLatency = SKIP_FIRST_LATENCY;\n    t = millis();\n    for (uint32_t i = 0; i < n; i++) {\n      uint32_t m = micros();\n      if (file.write(buf, BUF_SIZE) != BUF_SIZE) {\n        error("write failed");\n      }\n      m = micros() - m;\n      totalLatency += m;\n      if (skipLatency) {\n        // Wait until first write to SD, not just a copy to the cache.\n        skipLatency = file.curPosition() < 512;\n      } else {\n        if (maxLatency < m) {\n          maxLatency = m;\n        }\n        if (minLatency > m) {\n          minLatency = m;\n        }\n      }\n    }\n    file.sync();\n    t = millis() - t;\n    s = file.fileSize();\n    cout << s/t <<\',\' << maxLatency << \',\' << minLatency;\n    cout << \',\' << totalLatency/n << endl;\n  }\n  cout << endl << F("Starting read test, please wait.") << endl;\n  cout << endl <<F("read speed and latency") << endl;\n  cout << F("speed,max,min,avg") << endl;\n  cout << F("KB/Sec,usec,usec,usec") << endl;\n\n  // do read test\n  for (uint8_t nTest = 0; nTest < READ_COUNT; nTest++) {\n    file.rewind();\n    maxLatency = 0;\n    minLatency = 9999999;\n    totalLatency = 0;\n    skipLatency = SKIP_FIRST_LATENCY;\n    t = millis();\n    for (uint32_t i = 0; i < n; i++) {\n      buf[BUF_SIZE-1] = 0;\n      uint32_t m = micros();\n      int32_t nr = file.read(buf, BUF_SIZE);\n      if (nr != BUF_SIZE) {\n        error("read failed");\n      }\n      m = micros() - m;\n      totalLatency += m;\n      if (buf[BUF_SIZE-1] != \'\\n\') {\n\n        error("data check error");\n      }\n      if (skipLatency) {\n        skipLatency = false;\n      } else {\n        if (maxLatency < m) {\n          maxLatency = m;\n        }\n        if (minLatency > m) {\n          minLatency = m;\n        }\n      }\n    }\n    s = file.fileSize();\n    t = millis() - t;\n    cout << s/t <<\',\' << maxLatency << \',\' << minLatency;\n    cout << \',\' << totalLatency/n << endl;\n  }\n  cout << endl << F("Done") << endl;\n  file.close();\n}\n')),Object(r.b)("h3",{id:"exemplo-de-output"},"Exemplo de output"),Object(r.b)("p",null,"Obs: O output abaixo foi gerado numa vers\xe3o anterior desse c\xf3digo de testes, por\xe9m \xe9 bem parecido com o que voc\xea deve esperar."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-bash"},"Type any character to start\nFreeStack: 1037\nType is FAT32\nStarting print test.  Please wait.\n\nTest of println(uint16_t)\nTime 5.84 sec\nFile size 128.89 KB\nWrite 22.06 KB/sec\nMaximum latency: 11296 usec, Minimum Latency: 112 usec, Avg Latency: 281 usec\n\nTest of printField(uint16_t, char)\nTime 1.93 sec\nFile size 128.89 KB\nWrite 66.68 KB/sec\nMaximum latency: 39052 usec, Minimum Latency: 36 usec, Avg Latency: 85 usec\n\nTest of println(uint32_t)\nTime 9.09 sec\nFile size 200.00 KB\nWrite 22.00 KB/sec\nMaximum latency: 42996 usec, Minimum Latency: 380 usec, Avg Latency: 443 usec\n\nTest of printField(uint32_t, char)\nTime 2.67 sec\nFile size 200.00 KB\nWrite 75.05 KB/sec\nMaximum latency: 46644 usec, Minimum Latency: 64 usec, Avg Latency: 122 usec\n\nTest of println(float)\nTime 9.96 sec\nFile size 149.00 KB\nWrite 14.95 KB/sec\nMaximum latency: 43052 usec, Minimum Latency: 376 usec, Avg Latency: 487 usec\n\nTest of printField(float, char)\nTime 3.81 sec\nFile size 149.00 KB\nWrite 39.10 KB/sec\nMaximum latency: 46360 usec, Minimum Latency: 124 usec, Avg Latency: 179 usec\n\nDone!\n")))}d.isMDXComponent=!0},179:function(e,n,t){"use strict";t.d(n,"a",(function(){return d})),t.d(n,"b",(function(){return p}));var i=t(0),a=t.n(i);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=a.a.createContext({}),u=function(e){var n=a.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},d=function(e){var n=u(e.components);return a.a.createElement(l.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},f=a.a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),d=u(t),f=i,p=d["".concat(o,".").concat(f)]||d[f]||m[f]||r;return t?a.a.createElement(p,c(c({ref:n},l),{},{components:t})):a.a.createElement(p,c({ref:n},l))}));function p(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=f;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c.mdxType="string"==typeof e?e:i,o[1]=c;for(var l=2;l<r;l++)o[l]=t[l];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,t)}f.displayName="MDXCreateElement"}}]);